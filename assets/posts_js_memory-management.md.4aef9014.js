import{_ as e,c as a,o as i,a as l}from"./app.89a82245.js";const u=JSON.parse('{"title":"JS内存管理（垃圾回收机制）","description":"","frontmatter":{"title":"JS内存管理（垃圾回收机制）","date":"2019-01-22T11:35:09.000Z","tags":"JS"},"headers":[{"level":3,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":3,"title":"内存生命周期","slug":"内存生命周期","link":"#内存生命周期","children":[]},{"level":3,"title":"垃圾回收","slug":"垃圾回收","link":"#垃圾回收","children":[]}],"relativePath":"posts/js/memory-management.md"}'),t={name:"posts/js/memory-management.md"},r=l('<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h3><p>内存管理的主要目的就是在需要时系统动态的分配内存，不需要时把分配出去的内存再回收回来。 JS创建变量时就会分配内存，并且在不使用时”自动释放“。释放这一过程就叫垃圾回收。</p><h3 id="内存生命周期" tabindex="-1">内存生命周期 <a class="header-anchor" href="#内存生命周期" aria-hidden="true">#</a></h3><ol><li>分配所需内存</li><li>对内存进行读写操作</li><li>不需时释放/归还</li></ol><p>大多数内存管理的问题都在释放阶段，高级语言嵌入了”垃圾回收器“用于跟踪内存的分配和使用，以便分配的内存不再使用时，自动释放。</p><h3 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a></h3><p>垃圾回收算法主要依赖引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。</p><p>简单来说，分配好内存的对象被引用后一般情况下不会被回收。 在这里，对象的概念不仅指JS对象，还包括函数作用域或全局词法作用域。</p><p>当前最基本的垃圾回收算法有四种：</p><ol><li>标记-清除算法</li><li>标记-压缩算法</li><li>复制算法</li><li>引用计数算法</li></ol><p>根据MDN文档所示，2012年起所有的现代浏览器使用了标记-清除垃圾回收算法。所有对JS垃圾回收算法的改进都是基于标记-清除算法改进的。</p><h4 id="标记-清除算法" tabindex="-1">标记-清除算法 <a class="header-anchor" href="#标记-清除算法" aria-hidden="true">#</a></h4><p>标记清除算法从名称上看，可以拆分为两部分：标记和清除。</p><ul><li>标记阶段 在此阶段，垃圾回收器会从应用程序根对象（JS中，根是全局对象）开始遍历，每个从根对象访问到的对象都会添加一个标识，于是这个对象就被标识为可到达对象。</li><li>清除阶段 在此阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，发现没有标记的对象则将此对象占用的内存回收。</li></ul><p><img src="https://s2.ax1x.com/2019/01/22/kkCgBD.png" alt="kkCgBD.png"></p><p>在使用标记清除算法时，未引用对象并不会被立即回收，而是垃圾对象将累计到内存耗尽为止，当内存耗尽时，程序会被挂起，垃圾回收开始执行。</p><h4 id="标记清除算法的缺点" tabindex="-1">标记清除算法的缺点 <a class="header-anchor" href="#标记清除算法的缺点" aria-hidden="true">#</a></h4><ol><li>垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。</li><li>那些无法从根对象查询到的对象都将被清除。尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</li></ol>',18),n=[r];function o(s,d,h,c,p,_){return i(),a("div",null,n)}const f=e(t,[["render",o]]);export{u as __pageData,f as default};
