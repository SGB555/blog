import{_ as s,c as a,o as n,a as p}from"./app.89a82245.js";const h=JSON.parse('{"title":"第八章-混合对象“类”","description":"","frontmatter":{"layout":"youdtkonwjs","title":"第八章-混合对象“类”","date":"2018-11-12T22:15:51.000Z","tags":["你不知道的JavaScript","读书笔记"]},"headers":[{"level":3,"title":"类理论","slug":"类理论","link":"#类理论","children":[]},{"level":3,"title":"类机制","slug":"类机制","link":"#类机制","children":[]}],"relativePath":"posts/youdtkonwjs/dkjs-chapter-8.md"}'),l={name:"posts/youdtkonwjs/dkjs-chapter-8.md"},o=p(`<p><img src="https://ws1.sinaimg.cn/large/80676d79gy1fx7zuv75uaj20h905k3z2.jpg" alt=""></p><h3 id="类理论" tabindex="-1">类理论 <a class="header-anchor" href="#类理论" aria-hidden="true">#</a></h3><p>面向对象编程强调的是数据和操作数据的行为本质上是相关关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及它相关的行为打包或者说封装起来。</p><p>比如字符串，字符串是数据，而应用在这种数据上的行为（计算长度，添加数据，搜索等等）都会被设计成String类的方法。而字符串就是String类的一个实例。</p><p>再比如我们定义一个vehicle类和car类，vehicle可能包含了引擎，载人能力等，而car则会继承vehicle类的属性。</p><h4 id="类-设计模式" tabindex="-1">“类”设计模式 <a class="header-anchor" href="#类-设计模式" aria-hidden="true">#</a></h4><p>在软件设计中有很多面向类的设计模型，比如观察者模式，工厂模式，单例模式等等，也有函数式编程，面向过程编程。</p><h4 id="js中的-类" tabindex="-1">JS中的“类” <a class="header-anchor" href="#js中的-类" aria-hidden="true">#</a></h4><p>JS中没有类，有近似类的语法，es6中的类只是语法糖。</p><h3 id="类机制" tabindex="-1">类机制 <a class="header-anchor" href="#类机制" aria-hidden="true">#</a></h3><p>在许多面向类的语言中，“标准库”会提供 Stack 类，它是一种“栈”数据结构(支持压 入、弹出，等等)。Stack 类内部会有一些变量来存储数据，同时会提供一些公有的可访问 行为(“方法”)，从而让你的代码可以和(隐藏的)数据进行交互(比如添加、删除数据)。 但是在这些语言中，你实际上并不是直接操作 Stack(除非创建一个静态类成员引用，这 超出了我们的讨论范围)。Stack 类仅仅是一个抽象的表示，它描述了所有“栈”需要做的 事，但是它本身并不是一个“栈”。你必须先实例化 Stack 类然后才能对它进行操作。</p><h4 id="建造" tabindex="-1">建造 <a class="header-anchor" href="#建造" aria-hidden="true">#</a></h4><p>一个类就是一张蓝图。为了获得真正可以交互的对象，我们必须按照类来建造(也可以说 实例化)一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用 方法并访问其所有公有数据属性。</p><p>这个对象就是类中描述的所有特性的一份副本。</p><p>你通常也不会使用一个实例对象来直接访问并操作它的类，不过至少可以 判断出这个实例对象来自哪个类。</p><h4 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-hidden="true">#</a></h4><p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息。</p><p>注意，类通常有一个同名构造函数，执行时实际上调用的就是同名构造函数。构造函数会返回一个对象(也就是类的一个实例)，之后我们可以在这个对象上调用 类的 方法，来输出指定的值或数据。</p><h4 id="类的继承" tabindex="-1">类的继承 <a class="header-anchor" href="#类的继承" aria-hidden="true">#</a></h4><p>在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。后者通常被称为“子类”，前者通常被称为“父类”。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 伪代码</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Vehicle</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">engines</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">ignition</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">output</span><span style="color:#F07178;">( </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Turning on my engine.</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">drive</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">ignition</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">output</span><span style="color:#F07178;">( </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Steering and moving forward!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> )</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Car</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">inherits</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Vehicle</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">wheels</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">drive</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#FFCB6B;">inherited</span><span style="color:#89DDFF;">:</span><span style="color:#82AAFF;">drive</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">output</span><span style="color:#F07178;">( </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Rolling on all </span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wheels</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> wheels!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> )</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SpeedBoat</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">inherits</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Vehicle</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">engines</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">ignition</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">output</span><span style="color:#F07178;">( </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Turning on my </span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">engines</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> engines.</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> )</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">pilot</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#FFCB6B;">inherited</span><span style="color:#89DDFF;">:</span><span style="color:#82AAFF;">drive</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">output</span><span style="color:#F07178;">( </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Speeding through the water with ease!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> )</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="多态" tabindex="-1">多态 <a class="header-anchor" href="#多态" aria-hidden="true">#</a></h5><p>重写了继承至父类的方法，同时也可以引用继承来的原始方法，这个技术被称为多态或者虚拟多态。</p><p>在许多语言中可以使用super来表示当前类的父类/祖先类。 多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。</p><ol><li>传统的面向类语言中，子类构造函数可以通过super调用父类的构造函数</li><li>真正的类来说，构造函数属于类，但是在JS中，类属于构造函数</li></ol><p>子类得到的仅仅是继承至父类行为的一份副本。子类对继承到的一个方法进行‘重写’，不会影响到父类中的方法，这两个方法互不影响，因此才能使用相对多态引用访问父类中的方法（如果重写会影响父类的方法，那重写之后父类中的原始方法就不存在了，自然无法引用）</p><p>多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。</p><p>多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。</p><h5 id="多重继承" tabindex="-1">多重继承 <a class="header-anchor" href="#多重继承" aria-hidden="true">#</a></h5><p>从表面上来，对于类来说这似乎是一个非常有用的功能，可以把许多功能组合在一起。然 而，这个机制同时也会带来很多复杂的问题。如果两个父类中都定义了 drive() 方法的话， 子类引用的是哪个呢?难道每次都需要手动指定具体父类的 drive() 方法吗?这样多态继 承的很多优点就存在了。</p><h4 id="混入" tabindex="-1">混入 <a class="header-anchor" href="#混入" aria-hidden="true">#</a></h4><p>在继承或实例化时，JS的对象机制并不会自动执行复制行为。简单来说，JS中只有对象，并不存在可以被实例化的‘类’。一个对象并不会被复制到其他对象，它们会被关联起来。</p>`,32),e=[o];function t(r,c,F,y,i,D){return n(),a("div",null,e)}const A=s(l,[["render",t]]);export{h as __pageData,A as default};
