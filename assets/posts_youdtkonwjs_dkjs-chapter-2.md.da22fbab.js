import{_ as s,c as a,o as n,a as l}from"./app.0edfee5d.js";const A=JSON.parse('{"title":"第二章-词法作用域","description":"","frontmatter":{"layout":"youdtkonwjs","title":"第二章-词法作用域","date":"2018-08-22T00:00:00.000Z","tags":["你不知道的JavaScript","读书笔记"]},"headers":[{"level":3,"title":"词法阶段","slug":"词法阶段","link":"#词法阶段","children":[]},{"level":3,"title":"欺骗词法","slug":"欺骗词法","link":"#欺骗词法","children":[]}],"relativePath":"posts/youdtkonwjs/dkjs-chapter-2.md"}'),p={name:"posts/youdtkonwjs/dkjs-chapter-2.md"},o=l(`<p>刚完成第一章读书笔记之后。。紧接着就是连续的996 公事私事加起来导致很久没有写读书笔记，趁着最近不忙就赶紧补上</p><p>定义：作用域主要有两种。第一种是较为普遍的词法作用域也是JS采用的作用域模型；第二种是动态作用域。</p><p><img src="https://ws1.sinaimg.cn/large/80676d79gy1fung4zi1vcj21a104qt9o.jpg" alt=""></p><p><strong>内容:</strong></p><ol><li>词法阶段</li><li>欺骗词法</li></ol><h3 id="词法阶段" tabindex="-1">词法阶段 <a class="header-anchor" href="#词法阶段" aria-hidden="true">#</a></h3><p>第 1 章介绍过，大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。回 忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋 予单词语义。</p><p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域 不变(大部分情况下是这样的)。</p><h4 id="查找" tabindex="-1">查找 <a class="header-anchor" href="#查找" aria-hidden="true">#</a></h4><p>作用域查找会在找到第一个匹配的标识符时停止。 作用域查找始终是从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只是由函数被声明时所处的位置决定的</p><p>词法作用域查找只会查找一级标识符。如果代码中引用了foo.bar.baz 词法作用域查找只会找到foo，之后的查找就会被对象属性访问规则接管。</p><h3 id="欺骗词法" tabindex="-1">欺骗词法 <a class="header-anchor" href="#欺骗词法" aria-hidden="true">#</a></h3><p>JS中有两种机制来实现欺骗词法，重要的是 <strong>欺骗词法作用域会导致性能下降</strong></p><h4 id="eval" tabindex="-1">eval <a class="header-anchor" href="#eval" aria-hidden="true">#</a></h4><p>eval() 是全局对象的一个函数属性。</p><p>eval() 的参数是一个字符串。如果字符串表示的是表达式，eval() 会对表达式进行求值。如果参数表示一个或多个 JavaScript 语句， 那么 eval() 就会执行这些语句。注意不要用 eval() 来执行一个算术表达式；</p><p>例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">eval</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 欺骗</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">b</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">var b = =3</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 1,3</span></span>
<span class="line"></span></code></pre></div><p>由于eval(...)调用的代码声明了一个新的变量b,因此它对已经存在的词法作用域进行了修改。实际上就是，在foo(...)中创建了一个变量b把全局作用域的变量b遮蔽了 非严格模式下才能执行上述代码。</p><h4 id="with" tabindex="-1">with <a class="header-anchor" href="#with" aria-hidden="true">#</a></h4><p>with通常被当作重复引用同一个对象的多个属性的快捷方式，可以不需要重复引用对象本身。 例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">={</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">c</span><span style="color:#89DDFF;">:</span><span style="color:#F78C6C;">3</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">with</span><span style="color:#A6ACCD;">(obj)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">b</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">c</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>我们写的代码看起来只是对变量a的简单引用，实际上是一个LHS引用。当函数作用域以及全局作用域都没有查找到要引用的值时，就会创建一个全局变量，这样就改变了我们本来的目的（非严格模式）。</p><h4 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-hidden="true">#</a></h4><p>JS引擎在便器阶段会进行性能优化。而优化依赖于代码的词法静态分析，而以上两种机制就会导致无法预测从而放弃了优化。所以请不要使用它们</p>`,26),e=[o];function t(c,r,y,F,D,i){return n(),a("div",null,e)}const d=s(p,[["render",t]]);export{A as __pageData,d as default};
