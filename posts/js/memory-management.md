---
title: JS内存管理（垃圾回收机制）
date: 2019-01-22 11:35:09
tags: JS
---
### 前言
内存管理的主要目的就是在需要时系统动态的分配内存，不需要时把分配出去的内存再回收回来。
JS创建变量时就会分配内存，并且在不使用时”自动释放“。释放这一过程就叫垃圾回收。

### 内存生命周期
1. 分配所需内存
2. 对内存进行读写操作
3. 不需时释放/归还

大多数内存管理的问题都在释放阶段，高级语言嵌入了”垃圾回收器“用于跟踪内存的分配和使用，以便分配的内存不再使用时，自动释放。

### 垃圾回收
垃圾回收算法主要依赖引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。

简单来说，分配好内存的对象被引用后一般情况下不会被回收。
在这里，对象的概念不仅指JS对象，还包括函数作用域或全局词法作用域。

当前最基本的垃圾回收算法有四种：
1. 标记-清除算法
2. 标记-压缩算法
3. 复制算法
4. 引用计数算法

根据MDN文档所示，2012年起所有的现代浏览器使用了标记-清除垃圾回收算法。所有对JS垃圾回收算法的改进都是基于标记-清除算法改进的。

#### 标记-清除算法
标记清除算法从名称上看，可以拆分为两部分：标记和清除。
- 标记阶段
在此阶段，垃圾回收器会从应用程序根对象（JS中，根是全局对象）开始遍历，每个从根对象访问到的对象都会添加一个标识，于是这个对象就被标识为可到达对象。
- 清除阶段
在此阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，发现没有标记的对象则将此对象占用的内存回收。

![kkCgBD.png](https://s2.ax1x.com/2019/01/22/kkCgBD.png)

在使用标记清除算法时，未引用对象并不会被立即回收，而是垃圾对象将累计到内存耗尽为止，当内存耗尽时，程序会被挂起，垃圾回收开始执行。

#### 标记清除算法的缺点
1. 垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。
2. 那些无法从根对象查询到的对象都将被清除。尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。