---
layout: youdtkonwjs
title: 第八章-混合对象“类”
date: 2018-11-12 22:15:51
tags: ['你不知道的JavaScript','读书笔记']
---
![](https://ws1.sinaimg.cn/large/80676d79gy1fx7zuv75uaj20h905k3z2.jpg)

### 类理论
面向对象编程强调的是数据和操作数据的行为本质上是相关关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及它相关的行为打包或者说封装起来。

比如字符串，字符串是数据，而应用在这种数据上的行为（计算长度，添加数据，搜索等等）都会被设计成String类的方法。而字符串就是String类的一个实例。

再比如我们定义一个vehicle类和car类，vehicle可能包含了引擎，载人能力等，而car则会继承vehicle类的属性。

#### “类”设计模式
在软件设计中有很多面向类的设计模型，比如观察者模式，工厂模式，单例模式等等，也有函数式编程，面向过程编程。

#### JS中的“类”
JS中没有类，有近似类的语法，es6中的类只是语法糖。

### 类机制
在许多面向类的语言中，“标准库”会提供 Stack 类，它是一种“栈”数据结构(支持压 入、弹出，等等)。Stack 类内部会有一些变量来存储数据，同时会提供一些公有的可访问 行为(“方法”)，从而让你的代码可以和(隐藏的)数据进行交互(比如添加、删除数据)。
但是在这些语言中，你实际上并不是直接操作 Stack(除非创建一个静态类成员引用，这 超出了我们的讨论范围)。Stack 类仅仅是一个抽象的表示，它描述了所有“栈”需要做的 事，但是它本身并不是一个“栈”。你必须先实例化 Stack 类然后才能对它进行操作。

#### 建造
一个类就是一张蓝图。为了获得真正可以交互的对象，我们必须按照类来建造(也可以说 实例化)一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用 方法并访问其所有公有数据属性。

这个对象就是类中描述的所有特性的一份副本。

你通常也不会使用一个实例对象来直接访问并操作它的类，不过至少可以 判断出这个实例对象来自哪个类。

#### 构造函数
类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息。

注意，类通常有一个同名构造函数，执行时实际上调用的就是同名构造函数。构造函数会返回一个对象(也就是类的一个实例)，之后我们可以在这个对象上调用 类的 方法，来输出指定的值或数据。

#### 类的继承
在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。后者通常被称为“子类”，前者通常被称为“父类”。
```js
// 伪代码
class Vehicle {
    engines = 1
    ignition() {
        output( "Turning on my engine." );
    }
    drive() {
        ignition();
        output( "Steering and moving forward!" )
    }
}
class Car inherits Vehicle { 
    wheels = 4
    drive() {
        inherited:drive()
        output( "Rolling on all ", wheels, " wheels!" )
    } 
}
class SpeedBoat inherits Vehicle { 
    engines = 2
    ignition() {
        output( "Turning on my ", engines, " engines." )
    }
    pilot() {
        inherited:drive()
        output( "Speeding through the water with ease!" )
    } 
}
```

##### 多态
重写了继承至父类的方法，同时也可以引用继承来的原始方法，这个技术被称为多态或者虚拟多态。

在许多语言中可以使用super来表示当前类的父类/祖先类。
多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。

1. 传统的面向类语言中，子类构造函数可以通过super调用父类的构造函数
2. 真正的类来说，构造函数属于类，但是在JS中，类属于构造函数

子类得到的仅仅是继承至父类行为的一份副本。子类对继承到的一个方法进行‘重写’，不会影响到父类中的方法，这两个方法互不影响，因此才能使用相对多态引用访问父类中的方法（如果重写会影响父类的方法，那重写之后父类中的原始方法就不存在了，自然无法引用）

多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。

多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。

##### 多重继承
从表面上来，对于类来说这似乎是一个非常有用的功能，可以把许多功能组合在一起。然 而，这个机制同时也会带来很多复杂的问题。如果两个父类中都定义了 drive() 方法的话， 子类引用的是哪个呢?难道每次都需要手动指定具体父类的 drive() 方法吗?这样多态继 承的很多优点就存在了。

#### 混入
在继承或实例化时，JS的对象机制并不会自动执行复制行为。简单来说，JS中只有对象，并不存在可以被实例化的‘类’。一个对象并不会被复制到其他对象，它们会被关联起来。
